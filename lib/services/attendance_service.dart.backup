import 'dart:convert';
import 'package:shared_preferences/shared_preferences.dart';
import 'package:http/http.dart' as http;
import 'package:geolocator/geolocator.dart';
import 'package:image_picker/image_picker.dart';
import '../models/attendance_record.dart';
import '../config/env.dart';
import 'auth_service.dart';

class AttendanceService {
  static const String _attendanceKey = 'attendance_records';

  // Singleton pattern
  static final AttendanceService _instance = AttendanceService._internal();
  factory AttendanceService() => _instance;
  AttendanceService._internal();

  // Get all attendance records
  Future<List<AttendanceRecord>> getAllRecords() async {
    final prefs = await SharedPreferences.getInstance();
    final recordsJson = prefs.getStringList(_attendanceKey) ?? [];

    return recordsJson
        .map((json) => AttendanceRecord.fromJson(jsonDecode(json)))
        .toList();
  }

  Future<List<AttendanceRecord>> getAttendanceRecordsForDate(
    DateTime date,
  ) async {
    try {
      final token = await AuthService.getToken();
      if (token == null || token.isEmpty) {
        print('No authentication token available');
        return [];
      }

      // Format date as YYYY-MM-DD for the API
      String formattedDate =
          '${date.year}-${date.month.toString().padLeft(2, '0')}-${date.day.toString().padLeft(2, '0')}';
      final response = await http.get(
        Uri.parse('${Env.apiBaseUrl}/attendances?date=$formattedDate'),
        headers: {
          'Content-Type': 'application/json',
          'Accept': 'application/json',
          'Authorization': 'Bearer $token',
        },
      );

      print('Attendance API response: ${response.statusCode}');
      print('Attendance API body: ${response.body}');

      if (response.statusCode == 200) {
        final Map<String, dynamic> responseData = jsonDecode(response.body);
        if (responseData['success'] == true && responseData['data'] != null) {
          final List<dynamic> records = responseData['data'];
          return records
              .map((record) => AttendanceRecord.fromJson(record))
              .toList();
        }
      }
      return [];
    } catch (e) {
      print('Error fetching attendance data: $e');
      return [];
    }
  }

  // Update getRecordsByDateRange to use the new API structure
  Future<List<AttendanceRecord>> getRecordsByDateRange(
    DateTime startDate,
    DateTime endDate,
  ) async {
    try {
      final token = await AuthService.getToken();
      if (token == null || token.isEmpty) {
        print('No authentication token available');
        return [];
      }

      // Format dates for API
      String formattedStartDate =
          '${startDate.year}-${startDate.month.toString().padLeft(2, '0')}-${startDate.day.toString().padLeft(2, '0')}';
      String formattedEndDate =
          '${endDate.year}-${endDate.month.toString().padLeft(2, '0')}-${endDate.day.toString().padLeft(2, '0')}';

      final response = await http.get(
        Uri.parse(
          '${Env.apiBaseUrl}/attendances?start_date=$formattedStartDate&end_date=$formattedEndDate',
        ),
        headers: {
          'Content-Type': 'application/json',
          'Accept': 'application/json',
          'Authorization': 'Bearer $token',
        },
      );

      if (response.statusCode == 200) {
        final Map<String, dynamic> responseData = jsonDecode(response.body);
        if (responseData['success'] == true && responseData['data'] != null) {
          final List<dynamic> records = responseData['data'];
          return records
              .map((record) => AttendanceRecord.fromJson(record))
              .toList();
        }
      }
      return [];
    } catch (e) {
      print('Error fetching attendance data: $e');
      return [];
    }
  }

  // Get records by status
  Future<List<AttendanceRecord>> getRecordsByStatus(String status) async {
    final allRecords = await getAllRecords();
    return allRecords.where((record) => record.status == status).toList();
  }

  // Get today's record
  Future<AttendanceRecord?> getTodayRecord() async {
    final today = DateTime.now();
    final allRecords = await getAllRecords();

    try {
      // ‚úÖ Ambil semua record hari ini
      final todayRecords = allRecords.where((record) {
        return record.date.year == today.year &&
            record.date.month == today.month &&
            record.date.day == today.day;
      }).toList();

      if (todayRecords.isEmpty) {
        return null;
      }

      // ‚úÖ Sort by created time to get the most recent
      todayRecords.sort(
        (a, b) => (b.createdAt ?? DateTime(2000)).compareTo(
          a.createdAt ?? DateTime(2000),
        ),
      );

      // ‚úÖ Prioritaskan record yang masih checked-in
      final checkedInRecords = todayRecords
          .where((record) => record.isCheckedIn)
          .toList();
      final selectedRecord = checkedInRecords.isNotEmpty
          ? checkedInRecords.first
          : todayRecords.first; // Ambil yang paling baru

      print('üìã Found ${todayRecords.length} records for today');
      print('üîç Checked-in records: ${checkedInRecords.length}');
      print('‚úÖ Selected record ID: ${selectedRecord.id}');
      print(
        '‚úÖ Selected record: checkedIn=${selectedRecord.isCheckedIn}, store=${selectedRecord.storeName}',
      );
      print(
        '‚úÖ Selected record times: checkIn=${selectedRecord.checkInTime}, checkOut=${selectedRecord.checkOutTime}',
      );

      return selectedRecord;
    } catch (e) {
      print('‚ùå Error getting today record: $e');
      return null;
    }
  }

  // Save or update a record
  Future<void> saveRecord(AttendanceRecord record) async {
    final prefs = await SharedPreferences.getInstance();
    final allRecords = await getAllRecords();

    // Remove existing record with same ID
    allRecords.removeWhere((r) => r.id == record.id);

    // ‚úÖ Jika ini record check-in baru, hapus record lama yang sudah checkout hari ini
    if (record.checkInTime != null && record.checkOutTime == null) {
      final today = record.date;
      allRecords.removeWhere(
        (r) =>
            r.date.year == today.year &&
            r.date.month == today.month &&
            r.date.day == today.day &&
            r.checkOutTime != null && // Record yang sudah checkout
            r.id != record.id, // Kecuali record ini sendiri
      );
      print('üßπ Cleaned up old checkout records for today');
    }

    // Add updated record
    allRecords.add(record);

    // Save back to preferences
    final recordsJson = allRecords.map((r) => jsonEncode(r.toJson())).toList();

    print('üíæ Saving ${allRecords.length} total records');
    await prefs.setStringList(_attendanceKey, recordsJson);
  }

  // Create new record for today
  Future<AttendanceRecord> createTodayRecord() async {
    final today = DateTime.now();
    final existingRecord = await getTodayRecord();

    // ‚úÖ Jika sudah ada record dan masih checked-in, return existing
    if (existingRecord != null && existingRecord.isCheckedIn) {
      print('üìã Found existing checked-in record, using it');
      return existingRecord;
    }

    // ‚úÖ Jika ada record tapi sudah checkout, buat record baru untuk check-in baru
    print('üÜï Creating fresh record for new check-in');
    final newRecord = AttendanceRecord(
      id: '${today.year}${today.month.toString().padLeft(2, '0')}${today.day.toString().padLeft(2, '0')}_${today.millisecondsSinceEpoch}',
      date: today,
      createdAt: today,
      updatedAt: today,
    );

    await saveRecord(newRecord);
    return newRecord;
  }

  // Debug method to clear all attendance data (for testing)
  Future<void> clearAllAttendanceData() async {
    final prefs = await SharedPreferences.getInstance();
    await prefs.remove(_attendanceKey);
    print('üßπ Cleared all attendance data');
  }

  // Debug method to list all records
  Future<void> debugAllRecords() async {
    final allRecords = await getAllRecords();
    print('üìä Total records: ${allRecords.length}');
    for (var i = 0; i < allRecords.length; i++) {
      final r = allRecords[i];
      print(
        '   Record $i: ID=${r.id}, checkIn=${r.checkInTime}, checkOut=${r.checkOutTime}, isCheckedIn=${r.isCheckedIn}, store=${r.storeName}',
      );
    }
  }

  // Check in
  Future<AttendanceRecord> checkIn({
    required int storeId,
    required String storeName,
    required XFile image,
    required String note,
    required double distance, // Distance in meters
  }) async {
    try {
      // Get authentication token
      final token = await AuthService.getToken();
      if (token == null || token.isEmpty) {
        throw Exception('No authentication token available');
      }

      // Get current location with error handling
      Position position;
      try {
        // Check if location services are enabled
        bool serviceEnabled = await Geolocator.isLocationServiceEnabled();
        if (!serviceEnabled) {
          throw Exception('Location services are disabled');
        }

        // Check location permissions
        LocationPermission permission = await Geolocator.checkPermission();
        if (permission == LocationPermission.denied) {
          permission = await Geolocator.requestPermission();
          if (permission == LocationPermission.denied) {
            throw Exception('Location permissions are denied');
          }
        }

        if (permission == LocationPermission.deniedForever) {
          throw Exception('Location permissions are permanently denied');
        }

        position = await Geolocator.getCurrentPosition(
          desiredAccuracy: LocationAccuracy.medium,
          timeLimit: const Duration(seconds: 10),
        );
      } catch (e) {
        print('Location error: $e');
        // Use default location if GPS fails
        position = Position(
          latitude: -6.200000,
          longitude: 106.816666,
          timestamp: DateTime.now(),
          accuracy: 0.0,
          altitude: 0.0,
          altitudeAccuracy: 0.0,
          heading: 0.0,
          headingAccuracy: 0.0,
          speed: 0.0,
          speedAccuracy: 0.0,
        );
      }

      // Prepare multipart request
      var request = http.MultipartRequest(
        'POST',
        Uri.parse('${Env.apiBaseUrl}/attendances/check-in'),
      );

      // Add headers
      request.headers.addAll({
        'Accept': 'application/json',
        'Authorization': 'Bearer $token',
      });

      // Add fields
      final now = DateTime.now();
      request.fields.addAll({
        'date':
            '${now.year}-${now.month.toString().padLeft(2, '0')}-${now.day.toString().padLeft(2, '0')}',
        'store_id': storeId.toString(),
        'check_in_time': now.toIso8601String().split('T')[1].split('Z')[0],
        'latitude': position.latitude.toString(),
        'longitude': position.longitude.toString(),
        'note': note,
        'distance': distance.toString(), // Add distance field
        'is_out_itinerary': '0',
      });

      // Add image file
      request.files.add(await http.MultipartFile.fromPath('image', image.path));

      // Send request
      final streamedResponse = await request.send();
      final response = await http.Response.fromStream(streamedResponse);
      print('Check-in Request: ${request.fields}');

      print('Check-in API response: ${response.statusCode}');
      print('Check-in API body: ${response.body}');

      if (response.statusCode == 200) {
        // API call successful, save locally for offline access
        final today = DateTime.now();
        print('‚úÖ API check-in successful, saving local record...');

        // Debug current state
        await debugAllRecords();

        final record = await createTodayRecord();
        print(
          'üìã Base record: ${record.id}, checkIn=${record.checkInTime}, checkOut=${record.checkOutTime}',
        );

        final updatedRecord = record.copyWith(
          checkInTime: today,
          clearCheckOutTime: true, // ‚úÖ Explicitly clear checkout time
          storeId: storeId, // ‚úÖ Save store ID untuk checkout nanti
          storeName: storeName,
          status: 'checked_in',
          updatedAt: today,
        );

        print(
          'üíæ Saving updated record: checkIn=${updatedRecord.checkInTime}, checkOut=${updatedRecord.checkOutTime}, isCheckedIn=${updatedRecord.isCheckedIn}',
        );
        await saveRecord(updatedRecord);

        // Verify save
        final verifyRecord = await getTodayRecord();
        print(
          'üîç Verification record: checkIn=${verifyRecord?.checkInTime}, checkOut=${verifyRecord?.checkOutTime}, isCheckedIn=${verifyRecord?.isCheckedIn}',
        );

        return updatedRecord;
      } else {
        final errorData = jsonDecode(response.body);
        throw Exception(errorData['message'] ?? 'Check-in failed');
      }
    } catch (e) {
      print('‚ùå Error during check-in API: $e');
      print('üîÑ Using fallback local storage...');
      // Fallback to local storage if API fails
      final today = DateTime.now();

      final record = await createTodayRecord();
      print(
        'üìã Fallback base record: ${record.id}, checkIn=${record.checkInTime}, checkOut=${record.checkOutTime}',
      );

      final updatedRecord = record.copyWith(
        checkInTime: today,
        clearCheckOutTime: true, // ‚úÖ Explicitly clear checkout time
        storeId: storeId, // ‚úÖ Save store ID untuk checkout nanti
        storeName: storeName,
        status: 'checked_in',
        updatedAt: today,
      );

      print(
        'üíæ Fallback saving record: checkIn=${updatedRecord.checkInTime}, checkOut=${updatedRecord.checkOutTime}, isCheckedIn=${updatedRecord.isCheckedIn}',
      );
      await saveRecord(updatedRecord);

      // Verify save
      final verifyRecord = await getTodayRecord();
      print(
        'üîç Fallback verification: checkIn=${verifyRecord?.checkInTime}, checkOut=${verifyRecord?.checkOutTime}, isCheckedIn=${verifyRecord?.isCheckedIn}',
      );

      return updatedRecord;
    }
  }

  // Check out
  Future<AttendanceRecord> checkOut({
    required XFile image,
    required String note,
  }) async {
    print('üî¥ CHECKOUT CALLED!');
    print('üîç Stack trace: ${StackTrace.current}');
    try {
      // Get authentication token
      final token = await AuthService.getToken();
      if (token == null || token.isEmpty) {
        throw Exception('No authentication token available');
      }

      // Get current location with error handling
      Position position;
      try {
        // Check if location services are enabled
        bool serviceEnabled = await Geolocator.isLocationServiceEnabled();
        if (!serviceEnabled) {
          throw Exception('Location services are disabled');
        }

        // Check location permissions
        LocationPermission permission = await Geolocator.checkPermission();
        if (permission == LocationPermission.denied) {
          permission = await Geolocator.requestPermission();
          if (permission == LocationPermission.denied) {
            throw Exception('Location permissions are denied');
          }
        }

        if (permission == LocationPermission.deniedForever) {
          throw Exception('Location permissions are permanently denied');
        }

        position = await Geolocator.getCurrentPosition(
          desiredAccuracy: LocationAccuracy.medium,
          timeLimit: const Duration(seconds: 10),
        );
      } catch (e) {
        print('Location error: $e');
        // Use default location if GPS fails
        position = Position(
          latitude: -6.200000,
          longitude: 106.816666,
          timestamp: DateTime.now(),
          accuracy: 0.0,
          altitude: 0.0,
          altitudeAccuracy: 0.0,
          heading: 0.0,
          headingAccuracy: 0.0,
          speed: 0.0,
          speedAccuracy: 0.0,
        );
      }

      // Prepare multipart request
      var request = http.MultipartRequest(
        'POST',
        Uri.parse('${Env.apiBaseUrl}/attendances/check-out'),
      );

      // Add headers
      request.headers.addAll({
        'Accept': 'application/json',
        'Authorization': 'Bearer $token',
      });

      // Get current checked-in record to get store_id
      final currentRecord = await getTodayRecord();
      if (currentRecord == null || !currentRecord.isCheckedIn) {
        throw Exception('No active check-in found for checkout');
      }

      // Add fields including the required store_id
      final now = DateTime.now();
      request.fields.addAll({
        'date':
            '${now.year}-${now.month.toString().padLeft(2, '0')}-${now.day.toString().padLeft(2, '0')}',
        'store_id':
            currentRecord.storeId?.toString() ?? '0', // ‚úÖ Add missing store_id
        'check_out_time': now.toIso8601String().split('T')[1].split('Z')[0],
        'latitude': position.latitude.toString(),
        'longitude': position.longitude.toString(),
        'note': note,
        'is_out_itinerary': '1',
      });

      print('üì§ Checkout request fields: ${request.fields}');

      // Add image file
      request.files.add(await http.MultipartFile.fromPath('image', image.path));

      // Send request
      final streamedResponse = await request.send();
      final response = await http.Response.fromStream(streamedResponse);

      print('Check-out API response: ${response.statusCode}');
      print('Check-out API body: ${response.body}');

      if (response.statusCode == 200) {
        // API call successful, save locally for offline access
        final today = DateTime.now();

        final record = await getTodayRecord();
        if (record == null || record.checkInTime == null) {
          throw Exception('No check-in found for today');
        }

        // Calculate duration
        final duration = today.difference(record.checkInTime!).inMinutes;

        final updatedRecord = record.copyWith(
          checkOutTime: today,
          duration: duration,
          status: 'completed',
          updatedAt: today,
        );

        await saveRecord(updatedRecord);
        return updatedRecord;
      } else {
        final errorData = jsonDecode(response.body);
        throw Exception(errorData['message'] ?? 'Check-out failed');
      }
    } catch (e) {
      print('‚ùå Error during check-out API: $e');

      // ‚úÖ JANGAN update record jika API error!
      // Hanya rethrow error tanpa mengupdate local data
      throw Exception('Check-out failed: $e');

      // NOTE: Removed auto-fallback karena menyebabkan false checkout
      // User harus retry checkout jika gagal, jangan auto-update record
    }
  }

  // Get statistics
  Future<Map<String, dynamic>> getStatistics({
    DateTime? startDate,
    DateTime? endDate,
  }) async {
    final start =
        startDate ?? DateTime.now().subtract(const Duration(days: 30));
    final end = endDate ?? DateTime.now();

    final records = await getRecordsByDateRange(start, end);

    final totalDays = records.length;
    final completedDays = records.where((r) => r.isCompleted).length;
    final totalWorkingMinutes = records
        .where((r) => r.isCompleted)
        .fold(0, (sum, r) => sum + r.workingMinutes);

    final averageWorkingMinutes = completedDays > 0
        ? totalWorkingMinutes ~/ completedDays
        : 0;

    return {
      'totalDays': totalDays,
      'completedDays': completedDays,
      'totalWorkingMinutes': totalWorkingMinutes,
      'averageWorkingMinutes': averageWorkingMinutes,
      'completionRate': totalDays > 0
          ? (completedDays / totalDays * 100).round()
          : 0,
    };
  }

  // Clear all records (for testing)
  Future<void> clearAllRecords() async {
    final prefs = await SharedPreferences.getInstance();
    await prefs.remove(_attendanceKey);
  }

  // Get attendance records for calendar view
  Future<List<AttendanceRecord>> getAttendanceRecordsForCalendar({
    DateTime? startDate,
    DateTime? endDate,
  }) async {
    try {
      final token = await AuthService.getToken();
      if (token == null || token.isEmpty) {
        print('No authentication token available for calendar data');
        return [];
      }

      // Build query parameters
      String url = '${Env.apiBaseUrl}/attendances';
      List<String> queryParams = [];

      if (startDate != null) {
        queryParams.add(
          'start_date=${startDate.toIso8601String().split('T')[0]}',
        );
      }
      if (endDate != null) {
        queryParams.add('end_date=${endDate.toIso8601String().split('T')[0]}');
      }

      if (queryParams.isNotEmpty) {
        url += '?${queryParams.join('&')}';
      }

      final response = await http.get(
        Uri.parse(url),
        headers: {
          'Content-Type': 'application/json',
          'Accept': 'application/json',
          'Authorization': 'Bearer $token',
        },
      );

      print('Calendar attendance API response: ${response.statusCode}');
      print('Calendar attendance API body: ${response.body}');

      if (response.statusCode == 200) {
        final Map<String, dynamic> responseData = jsonDecode(response.body);
        if (responseData['success'] == true && responseData['data']['details'] != null) {
          final List<dynamic> records = responseData['data']['details'] as List<dynamic>;
          return records
              .map((record) => AttendanceRecord.fromJson(record))
              .toList();
        }
      }

      return [];
    } catch (e) {
      print('Error fetching calendar attendance data: $e');
      return [];
    }
  }

  // // Get attendance records for a specific date
  // Future<List<AttendanceRecord>> getAttendanceRecordsForDate(
  //   DateTime date,
  // ) async {
  //   final startOfDay = DateTime(date.year, date.month, date.day);
  //   final endOfDay = startOfDay.add(const Duration(days: 1));

  //   return await getAttendanceRecordsForCalendar(
  //     startDate: startOfDay,
  //     endDate: endOfDay,
  //   );
  // }

  // Get attendance records for a week
  Future<List<AttendanceRecord>> getAttendanceRecordsForWeek(
    DateTime weekStart,
  ) async {
    final weekEnd = weekStart.add(const Duration(days: 6));

    return await getAttendanceRecordsForCalendar(
      startDate: weekStart,
      endDate: weekEnd,
    );
  }

  // Get attendance records for a month
  Future<List<AttendanceRecord>> getAttendanceRecordsForMonth(
    DateTime month,
  ) async {
    final startOfMonth = DateTime(month.year, month.month, 1);
    final endOfMonth = DateTime(month.year, month.month + 1, 0);

    return await getAttendanceRecordsForCalendar(
      startDate: startOfMonth,
      endDate: endOfMonth,
    );
  }

  // Break functionality
  Future<AttendanceRecord> startBreak({required String recordId}) async {
    try {
      final allRecords = await getAllRecords();
      final recordIndex = allRecords.indexWhere((r) => r.id.toString() == recordId);
      
      if (recordIndex == -1) {
        throw Exception('Attendance record not found');
      }

      final record = allRecords[recordIndex];
      
      // Check if already on break
      if (record.isOnBreak) {
        throw Exception('Already on break');
      }

      // Check if checked in
      if (!record.isCheckedIn) {
        throw Exception('Must be checked in to start break');
      }

      // Check total break time limit (60 minutes)
      if (record.totalBreakMinutes >= 60) {
        throw Exception('Daily break limit (60 minutes) reached');
      }

      final now = DateTime.now();
      final updatedRecord = record.copyWith(
        isOnBreak: true,
        breakStartTime: now,
        updatedAt: now,
      );

      allRecords[recordIndex] = updatedRecord;
      await saveRecord(updatedRecord);
      
      print('‚úÖ Break started at ${now.toString()}');
      return updatedRecord;
    } catch (e) {
      print('‚ùå Error starting break: $e');
      rethrow;
    }
  }

  Future<AttendanceRecord> endBreak({required String recordId}) async {
    try {
      final allRecords = await getAllRecords();
      final recordIndex = allRecords.indexWhere((r) => r.id.toString() == recordId);
      
      if (recordIndex == -1) {
        throw Exception('Attendance record not found');
      }

      final record = allRecords[recordIndex];
      
      // Check if on break
      if (!record.isOnBreak || record.breakStartTime == null) {
        throw Exception('Not currently on break');
      }

      final now = DateTime.now();
      final breakDuration = now.difference(record.breakStartTime!).inMinutes;
      
      // Create new break session
      final breakSession = BreakSession(
        startTime: record.breakStartTime!,
        endTime: now,
        duration: breakDuration,
      );

      // Update break sessions list
      final updatedBreakSessions = List<BreakSession>.from(record.breakSessions);
      updatedBreakSessions.add(breakSession);

      final updatedRecord = record.copyWith(
        isOnBreak: false,
        breakStartTime: null,
        totalBreakMinutes: record.totalBreakMinutes + breakDuration,
        breakSessions: updatedBreakSessions,
        updatedAt: now,
      );

      allRecords[recordIndex] = updatedRecord;
      await saveRecord(updatedRecord);
      
      print('‚úÖ Break ended. Duration: ${breakDuration}m. Total break time: ${updatedRecord.totalBreakMinutes}m');
      return updatedRecord;
    } catch (e) {
      print('‚ùå Error ending break: $e');
      rethrow;
    }
  }

  // Force end break when limit reached
  Future<AttendanceRecord> forceEndBreak({required String recordId}) async {
    try {
      print('‚ö†Ô∏è Force ending break due to 60-minute limit');
      return await endBreak(recordId: recordId);
    } catch (e) {
      print('‚ùå Error force ending break: $e');
      rethrow;
    }
  }

  // Get current break duration in seconds
  int getCurrentBreakDuration(AttendanceRecord record) {
    if (!record.isOnBreak || record.breakStartTime == null) {
      return 0;
    }
    return DateTime.now().difference(record.breakStartTime!).inSeconds;
  }

  // Check if break limit is approaching (50+ minutes)
  bool isBreakLimitApproaching(AttendanceRecord record) {
    if (!record.isOnBreak) return false;
    final currentBreakMinutes = getCurrentBreakDuration(record) ~/ 60;
    return (record.totalBreakMinutes + currentBreakMinutes) >= 50;
  }

  // Check if break limit is reached
  bool isBreakLimitReached(AttendanceRecord record) {
    if (!record.isOnBreak) return false;
    final currentBreakMinutes = getCurrentBreakDuration(record) ~/ 60;
    return (record.totalBreakMinutes + currentBreakMinutes) >= 60;
  }
}
